#!/bin/sh

# File path: /lib/preinit/resize_rootfs.sh
# Make executable: chmod +x /lib/preinit/resize_rootfs.sh

# Define paths for flag files stored in /etc
PARTITION_RESIZED_FLAG="/etc/.partition_resized"
FILESYSTEM_RESIZED_FLAG="/etc/.filesystem_resized"

# Function to log messages to the system log
log() {
    logger -t resize_rootfs "$1"
}

# Get the root partition device, e.g., /dev/sda1, /dev/nvme0n1p1, /dev/mmcblk0p2
ROOT_DEV=$(df / | tail -1 | awk '{print $1}')

# Function to extract the base disk from the root partition device
get_base_disk() {
    local dev="$1"
    if echo "$dev" | grep -q '^/dev/nvme'; then
        # For NVMe devices, e.g., /dev/nvme0n1p1 → /dev/nvme0n1
        echo "$dev" | sed -E 's/p[0-9]+$//'
    elif echo "$dev" | grep -q '^/dev/mmcblk'; then
        # For MMC devices, e.g., /dev/mmcblk0p2 → /dev/mmcblk0
        echo "$dev" | sed -E 's/p[0-9]+$//'
    else
        # For standard devices, e.g., /dev/sda1 → /dev/sda
        echo "$dev" | sed 's/[0-9]*$//'
    fi
}

DISK=$(get_base_disk "$ROOT_DEV")

# Confirm the DISK path exists
if [ ! -b "$DISK" ]; then
    log "Disk device $DISK does not exist."
    exit 1
fi

# Function to get the partition number from the root device
get_partition_num() {
    local dev="$1"
    if echo "$dev" | grep -q '^/dev/nvme'; then
        echo "$dev" | grep -o 'p[0-9]\+$' | sed 's/p//'
    elif echo "$dev" | grep -q '^/dev/mmcblk'; then
        echo "$dev" | grep -o 'p[0-9]\+$' | sed 's/p//'
    else
        echo "$dev" | grep -o '[0-9]\+$'
    fi
}

PARTITION_NUM=$(get_partition_num "$ROOT_DEV")

# Function to construct the full partition path
get_partition_path() {
    local disk="$1"
    local num="$2"
    if echo "$disk" | grep -q '^/dev/nvme'; then
        echo "${disk}p${num}"
    elif echo "$disk" | grep -q '^/dev/mmcblk'; then
        echo "${disk}p${num}"
    else
        echo "${disk}${num}"
    fi
}

PARTITION_PATH=$(get_partition_path "$DISK" "$PARTITION_NUM")

# If the filesystem has already been resized, exit
if [ -f "$FILESYSTEM_RESIZED_FLAG" ]; then
    log "Filesystem has already been resized."
    exit 0
fi

# If the partition has already been resized, proceed to resize the filesystem
if [ -f "$PARTITION_RESIZED_FLAG" ]; then
    log "Resizing filesystem..."
    # Check if the filesystem type is ext4
    if mount | grep "$PARTITION_PATH" | grep -q 'ext4'; then
        resize2fs "$PARTITION_PATH"
        if [ $? -eq 0 ]; then
            log "Filesystem resized successfully."
            touch "$FILESYSTEM_RESIZED_FLAG"
        else
            log "Failed to resize filesystem."
        fi
    else
        log "Unsupported filesystem type. Skipping resize."
    fi
    exit 0
fi

# Get the total number of sectors on the disk
DISK_SIZE_SECT=$(cat /sys/block/$(basename "$DISK")/size)
if [ -z "$DISK_SIZE_SECT" ]; then
    log "Unable to get sector count for disk $DISK."
    exit 1
fi

# Get the size of each sector (usually 512 bytes)
SECTOR_SIZE=$(cat /sys/block/$(basename "$DISK")/queue/hw_sector_size)
if [ -z "$SECTOR_SIZE" ]; then
    log "Unable to get sector size for disk $DISK."
    exit 1
fi

# Calculate the number of sectors corresponding to 10MB
SECTORS_10MB=$((10 * 1024 * 1024 / SECTOR_SIZE))

# Calculate the new end sector (total sectors - sectors for 10MB)
NEW_END_SECT=$((DISK_SIZE_SECT - SECTORS_10MB))

log "Total disk sectors: $DISK_SIZE_SECT"
log "Sector size: $SECTOR_SIZE bytes"
log "Reserving last 10MB: $SECTORS_10MB sectors"
log "New end sector for partition $PARTITION_PATH: $NEW_END_SECT"

# Function to get the starting sector of the current partition
get_start_sector() {
    fdisk -l "$DISK" 2>/dev/null | grep "^$PARTITION_PATH " | awk '{print $2}'
}

START_SECTOR=$(get_start_sector)
if [ -z "$START_SECTOR" ]; then
    log "Unable to get start sector for partition $PARTITION_PATH."
    exit 1
fi

log "Partition $PARTITION_PATH starts at sector: $START_SECTOR"

# Backup the current partition table
sfdisk -d "$DISK" > "/etc/$(basename "$DISK")_sfdisk_backup"
if [ $? -ne 0 ]; then
    log "Failed to backup the partition table of $DISK."
    exit 1
fi

log "Backing up current partition table."

# Modify the partition table using sfdisk
log "Modifying the partition table using sfdisk..."

# Use sfdisk to delete the existing partition and recreate it with the new end sector
(
    echo "d"
    echo "$PARTITION_NUM"
    echo "n"
    echo "$PARTITION_NUM"
    echo "$START_SECTOR"
    echo "$NEW_END_SECT"
    echo "w"
) | sfdisk "$DISK" >/dev/null 2>&1

if [ $? -ne 0 ]; then
    log "Failed to modify the partition table. Restoring from backup."
    sfdisk "$DISK" < "/etc/$(basename "$DISK")_sfdisk_backup"
    log "Partition table restored from backup."
    exit 1
fi

log "Partition table modified successfully."

# Synchronize disk changes
sync

# Mark that the partition has been resized and the filesystem needs to be resized
touch "$PARTITION_RESIZED_FLAG"

log "Partition resized. Rebooting to apply changes."

# Reboot the system to apply the new partition table
reboot

# The script will exit here and continue after reboot to resize the filesystem
exit 0