#!/bin/sh

# File path: /lib/preinit/resize_rootfs.sh
# Make executable: chmod +x /lib/preinit/resize_rootfs.sh

# Define paths for flag files stored in /etc
PARTITION_RESIZED_FLAG="/etc/.partition_resized"
FILESYSTEM_RESIZED_FLAG="/etc/.filesystem_resized"

# Function to log messages to the system log
log() {
    logger -t resize_rootfs "$1"
}

# Function to extract the base disk from the root partition device
get_base_disk() {
    local dev="$1"
    if echo "$dev" | grep -q '^/dev/nvme'; then
        # For NVMe devices, e.g., /dev/nvme0n1p1 -> /dev/nvme0n1
        echo "$dev" | sed -E 's/p[0-9]+$//'
    elif echo "$dev" | grep -q '^/dev/mmcblk'; then
        # For MMC devices, e.g., /dev/mmcblk0p2 -> /dev/mmcblk0
        echo "$dev" | sed -E 's/p[0-9]+$//'
    else
        # For standard devices, e.g., /dev/sda1 -> /dev/sda
        echo "$dev" | sed 's/[0-9]*$//'
    fi
}

# Get the root partition device, e.g., /dev/sda1, /dev/nvme0n1p1, /dev/mmcblk0p2
ROOT_DEV=$(df / | tail -1 | awk '{print $1}')

# Extract the base disk device
DISK=$(get_base_disk "$ROOT_DEV")

# Confirm the DISK path exists
if [ ! -b "$DISK" ]; then
    log "Disk device $DISK does not exist."
    exit 1
fi

# Function to get the partition number from the root device
get_partition_num() {
    local dev="$1"
    if echo "$dev" | grep -q '^/dev/nvme'; then
        echo "$dev" | grep -o 'p[0-9]\+$' | sed 's/p//'
    elif echo "$dev" | grep -q '^/dev/mmcblk'; then
        echo "$dev" | grep -o 'p[0-9]\+$' | sed 's/p//'
    else
        echo "$dev" | grep -o '[0-9]\+$'
    fi
}

PARTITION_NUM=$(get_partition_num "$ROOT_DEV")

# Function to construct the full partition path
get_partition_path() {
    local disk="$1"
    local num="$2"
    if echo "$disk" | grep -q '^/dev/nvme'; then
        echo "${disk}p${num}"
    elif echo "$disk" | grep -q '^/dev/mmcblk'; then
        echo "${disk}p${num}"
    else
        echo "${disk}${num}"
    fi
}

PARTITION_PATH=$(get_partition_path "$DISK" "$PARTITION_NUM")

# If the filesystem has already been resized, exit
if [ -f "$FILESYSTEM_RESIZED_FLAG" ]; then
    log "Filesystem has already been resized."
    exit 0
fi

# If the partition has already been resized, proceed to resize the filesystem
if [ -f "$PARTITION_RESIZED_FLAG" ]; then
    log "Resizing filesystem..."
    # Check if the filesystem type is ext4
    if mount | grep "$PARTITION_PATH" | grep -q 'ext4'; then
        resize2fs "$PARTITION_PATH"
        if [ $? -eq 0 ]; then
            log "Filesystem resized successfully."
            touch "$FILESYSTEM_RESIZED_FLAG"
        else
            log "Failed to resize filesystem."
        fi
    else
        log "Unsupported filesystem type. Skipping resize."
    fi
    exit 0
fi

# Get the total number of sectors on the disk
DISK_SIZE_SECT=$(cat /sys/block/$(basename "$DISK")/size)
if [ -z "$DISK_SIZE_SECT" ]; then
    log "Unable to get sector count for disk $DISK."
    exit 1
fi

# Get the size of each sector (usually 512 bytes)
SECTOR_SIZE=$(cat /sys/block/$(basename "$DISK")/queue/hw_sector_size)
if [ -z "$SECTOR_SIZE" ]; then
    log "Unable to get sector size for disk $DISK."
    exit 1
fi

# Calculate the number of sectors corresponding to 10MB
SECTORS_10MB=$((10 * 1024 * 1024 / SECTOR_SIZE))

# Calculate the new end sector (total sectors - sectors for 10MB)
NEW_END_SECT=$((DISK_SIZE_SECT - SECTORS_10MB))

log "Total disk sectors: $DISK_SIZE_SECT"
log "Sector size: $SECTOR_SIZE bytes"
log "Reserving last 10MB: $SECTORS_10MB sectors"
log "New end sector for partition $PARTITION_PATH: $NEW_END_SECT"

# Function to get the starting sector of the current partition
get_start_sector() {
    fdisk -l "$DISK" 2>/dev/null | awk -v part="$PARTITION_PATH" '$1 == part {print $2}'
}

START_SECTOR=$(get_start_sector)
if [ -z "$START_SECTOR" ]; then
    log "Unable to get start sector for partition $PARTITION_PATH."
    exit 1
fi

log "Partition $PARTITION_PATH starts at sector: $START_SECTOR"

# Determine the partition table type (gpt or dos)
PART_TYPE=$(fdisk -l "$DISK" 2>/dev/null | grep -i 'Disklabel type:' | awk '{print $NF}')

if [ "$PART_TYPE" = "gpt" ]; then
    PT_TYPE="gpt"
    log "Partition table type detected: GPT"
else
    PT_TYPE="mbr"
    log "Partition table type detected: MBR"
fi

# Backup the current partition table
fdisk -l "$DISK" > "/etc/$(basename "$DISK")_fdisk_backup.log" 2>&1
if [ $? -ne 0 ]; then
    log "Failed to backup the partition table of $DISK."
    exit 1
fi

log "Backing up current partition table."

# Modify the partition table using fdisk
log "Modifying the partition table using fdisk..."

if [ "$PT_TYPE" = "gpt" ]; then
    # GPT: No need to specify partition type
    (
        echo "d"              # Delete partition
        echo "$PARTITION_NUM"  # Partition number
        echo "n"              # New partition
        echo "$PARTITION_NUM"  # Partition number
        echo "$START_SECTOR"   # Start sector
        echo "$NEW_END_SECT"   # End sector
        echo "w"              # Write changes
    ) | fdisk "$DISK" >/dev/null 2>&1
else
    # MBR: Need to specify partition type (primary 'p')
    (
        echo "d"              # Delete partition
        echo "$PARTITION_NUM"  # Partition number
        echo "n"              # New partition
        echo "p"              # Primary partition
        echo "$PARTITION_NUM"  # Partition number
        echo "$START_SECTOR"   # Start sector
        echo "$NEW_END_SECT"   # End sector
        echo "w"              # Write changes
    ) | fdisk "$DISK" >/dev/null 2>&1
fi

if [ $? -ne 0 ]; then
    log "Failed to modify the partition table. Attempting to restore from backup."
    # Attempt to restore from the backup
    (
        echo "d"              # Delete the newly modified partition (if any)
        echo "$PARTITION_NUM"  # Partition number
        echo "n"              # New partition
        # Determine partition type based on original partition table
        if [ "$PT_TYPE" != "gpt" ]; then
            echo "p"              # Primary partition
        fi
        echo "$PARTITION_NUM"    # Partition number
        echo "$START_SECTOR"     # Start sector
        # Extract the original end sector from backup
        ORIG_END_SECT=$(grep "^$PARTITION_PATH " "/etc/$(basename "$DISK")_fdisk_backup.log" | awk '{print $3}')
        echo "$ORIG_END_SECT"     # Original end sector
        echo "w"                  # Write changes
    ) | fdisk "$DISK" >/dev/null 2>&1

    if [ $? -ne 0 ]; then
        log "Failed to restore the partition table from backup. Manual intervention required."
        exit 1
    fi

    log "Partition table restored from backup."
    exit 1
fi

log "Partition table modified successfully."

# Synchronize disk changes
sync

# Mark that the partition has been resized and the filesystem needs to be resized
touch "$PARTITION_RESIZED_FLAG"

log "Partition resized. Rebooting to apply changes."

# Reboot the system to apply the new partition table
reboot

# The script will exit here and continue after reboot to resize the filesystem
exit 0